\chapter{System Design}
\label{sec:systemDesign}
Zur Erfüllung der im vorherigen Kapitel dargestellten Use-Cases wurde sich auf ein System mit drei Teilen geeinigt. Zunächst benötigt das System ein Gerät zur Aufzeichnung der OBD-Daten. Da dieses Gerät der Bequemlichkeit wegen im Fahrzeug verbleiben soll und vermutlich wenig Ressourcen besitzt, verfügt das geplante System zusätzlich noch über ein Backend welches die aufgezeichneten Daten langfristig speichern und auswerten soll. Zusätzlich erfolgt noch eine Anbindung einer Smartphone-App, welche die Fahrzeug-Daten während der Fahrt veranschaulichen soll. Der Vorteil dieser Lösung liegt in der Möglichkeit, die Software der drei Komponenten OBD-Dongle, App und Backend paralell entwickeln zu können. Somit ergibt sich das in Abbildung \ref{fig:SysArch} dargestellte System.
\begin{figure}[h]
  \begin{center}
    \includegraphics[height=7cm,keepaspectratio]{./img/SysArch}
    \caption{Darstellung des Systems im Kontext}
    \label{fig:SysArch}
  \end{center}
\end{figure}



\section{App}
Um die Fahrzeugdaten während der Fahrt analysieren zu können, sowie auch ein einfacher Weg die Daten vom OBD-Dongle ins Backend zu übertragen, wurde eine plattformübergreifende Smartphone-App erstellt. Die App ist sowohl für Android, IOS als auch Windows verfügbar. Dafür wurde das für mobile Anwendungen konzipierte Framework Apache Cordova verwendet. Dieses Entwicklung-Framework verwendet die standard-Web-Technologien HTML5, CSS3 und JavaScript für die Cross-Plattform-Entwicklung. Die Bibliothek visualisiert die Anwendung mittels, die von den einzelnen Plattformen bereitgestellten, \enquote{WebViews}. Diese zeigen die Sourcen vergleichbar einer \enquote{Webseite} in einen Browser-Container an. Der Zugriff auf native Funktionen erfolgt über Cordova, bzw. weiteren, nativ geschriebenen, Plugins.
\\
Bei der Entwicklung wurde mit den Spracherweiterungen TypeScript und Sass gearbeitet. Diese werden in die standard-Web-Sprachen JavaScript und CSS compiliert. TypeScript bringt den großen Vorteil von festen Typen, Klassen, Namespaces, Vererbungen und vieles mehr. Dadurch wird die Weiterentwicklung und Wartung im Team enorm vereinfacht, da z.B. die einzelnen Module klar, durch Klassen und Namespaces, abgegrenzt sind. Auch der Nutzen von Variablen, durch die festen Typen, ist schneller und leichter ohne das lesen der Dokumentation oder Kommentare, erkennbar. Ein sogar noch größerer Vorteil von TypeScript ist, das die gewünschte ECMA Script Version bei Generierung einstellbar ist. Das heißt, falls ein älteres Smartphone unterstützt werden soll, kann diese auch bis zu ECMA Script 3 (aus dem Jahre 1999) runter gestellt werden. Dies geht zwar auf die Kosten der Performance jedoch wäre das native schreiben in JavaScript mit ECMA Script 3 keine wahre Alternative. 
\\
Des weiteren wurde SASS in Stelle von CSS verwendet, welches die Standard CSS-Syntax um Variablen, Vererbung sowie Makros erweitert. Dadurch kann die Weiterentwicklung als auch die Wartung weiter erleichtert werden. Zudem ermöglicht SASS auch das generieren von verschiedenen Versionen von CSS, um auch hier eine möglichst gute Abwärtskompatibilität zu gewährleisten. Eine weitere oft verwendete Funktion, ist das verwendet von Makros, welche z.B. das einbetten von Bildern in die Style-Datei ermöglicht (Siehe \ref{sec:appGrundgerust}). 

\subsection{Aufbau}
Die App ist von Beginn an in fünf große Bereiche eingeteilt, welche sich jeweils als eigene Komponente (siehe Abbildung \ref{fig:appKomponentendiagramm}) gliedern. Des Weiteren sind noch, zur besseren Handhabbarkeit, Unterkomponenten eingebaut, sowie Aufspaltungen der Komponenten vorgenommen worden.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.75\textwidth]{./img/App_Komponentendiagramm}
    \caption{Komponentendiagramm der Smartphone-App}
    \label{fig:appKomponentendiagramm}
  \end{center}
\end{figure}

Die \enquote{Helpers}-Komponente (siehe Abbildung \ref{fig:appKlassendiagrammHelpers}) besteht aus Hilfsklassen und Funktionen, die von sämtlichen anderen Hauptmodulen verwendet werden können. Dabei sind die Klassen mit dem Single-Pattern versehen und somit jederzeit über die statischen Instanzen in den jeweiligen Namespaces zugreifbar. 

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{./img/App_Klassendiagramm_Helpers}
    \caption{Klassendiagramm Komponente \enquote{Helpers}}
    \label{fig:appKlassendiagrammHelpers}
  \end{center}
\end{wrapfigure}

Die \enquote{Variables} Dateien enthalten eine Liste von allen HTML IDs und Klassen Namen, die über HTML, TypeScript als auch über SASS zugegriffen werden können. Die Liste wird nur als TypeScript Objekt in JSON-Format gepflegt und automatisch, beim kompilieren, als SASS Variablen generiert (Siehe Kapitel \ref{sec:appGrundgerust}).
\\
Für das Speichern aktueller Benutzereinstellungen und Konfigurationen (z.B. bei Neustart der App wird die letzte ausgewählte View gesetzt) steht die Klasse \enquote{Store} zur Verfügung (Siehe Kapitel \ref{ration}). Hier werden die Daten als Key-Value-Paar in die Browser eigenen \enquote{Local/Session Storage} gespeichert. Dabei können die Daten entweder flüchtig in den \enquote{Session Store} oder permanent in den \enquote{Local Store} eingetragen werden. 
\\
Um die Anforderung der Mehrsprachigkeit zu gewährleisten, werden alle benötigten Texte nicht \enquote{Hard Coded} in die Quelldateien eingefügt, sondern in die \enquote{Strings} Klasse (Siehe Kapitel \ref{sec:appMehrsprachigkeit}) ausgelagert. Hier sind alle Texte in jeder verfügbaren Sprache gespeichert. Außerdem verfügt sie über eine Funktion, welche automatisch den Text in der richtigen Sprache zurückgibt.
\\
Außerdem enthält die Komponente die \enquote{Settings} Klasse, die alle zur Verfügung stehenden festen Einstellungen, Standardwerte sowie Definitionen (z.B. PIDs, Storage-Keys, ClientId für den Identity Server) beinhaltet.

\paragraph{}

\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{./img/App_Klassendiagramm_Logging}
    \caption{Klassendiagramm Komponente \enquote{Logging}}
    \label{fig:appKlassendiagrammLogging}
    \includegraphics[width=0.5\textwidth]{./img/App_Klassendiagramm_Dongle}
    \caption{Klassendiagramm Komponente \enquote{Dongle}}
    \label{fig:appKlassendiagrammDongle}
    \includegraphics[width=0.5\textwidth]{./img/App_Klassendiagramm_Mobile}
    \caption{Klassendiagramm Komponente \enquote{Mobile}}
    \label{fig:appKlassendiagrammMobile}
  \end{center}
\end{wrapfigure}

Für die Pflege der App ist ein Protokollierung der Handlungen sowie der Fehler unumgänglich. Dazu steht die Komponente \enquote{Logging} (siehe Abbildung \ref{fig:appKlassendiagrammLogging}) zur Verfügung. Diese enthält eine Liste von \enquote{ErrorLogEntry}'s, welche zum einen automatisch mit Systemmeldungen gefüttert wird, sowie zum anderen von jeder Komponente bespeist werden kann. Außerdem kann die Liste bei Bedarf auf der Konfigurationssicht (siehe Kapitel \ref{sec:appSichtKonfiguration}) angezeigt werden.
\\
In der Komponente \enquote{Dongle} (siehe Abbildung \ref{fig:appKlassendiagrammDongle}) befindet sich aktuell nur die \enquote{Bluetooth} Klasse. Diese kümmert sich um die Bluetooth Verbindung und Kommunikation mit dem Dongle (siehe Kapitel \ref{sec:appBluetooth}).
Weitere Klassen werden in Zukunft unter anderen das Herunterladen der Loggingdaten, sowie das flashen des Dongle's mit neuer Firmware sein (siehe Kapitel \ref{sec:appAusblick}).
\\
Die Verbindung zu den nativen Schnittstellen zum Smartphone kümmert sich das Modul \enquote{Mobile} (siehe Abbildung \ref{fig:appKlassendiagrammMobile})) und beinhaltet die benötigten GPS Funktionen (siehe Kapitel \ref{sec:appGPS}).

\paragraph{}

Die App ist grafisch in Ansichten, die durch das Wischen nach links oder rechts durchgeschaltet werden können, eingeteilt. Diese werden von der Komponente \enquote{View} (siehe Abbildung \ref{fig:appKlassendiagrammView}) verwaltet. Zurzeit stehen vier Ansichten zur Verfügung. Eine Konfigurationssicht (siehe Kapitel \ref{sec:appSichtKonfiguration}), in der Einstellungen, Verbindungsoptionen und Funktionen zum Down- und Upload der Loggingdaten zur Verfügung stehen und drei verschiedene Anzeigesichten für Livedaten (z.B. Tacho) (siehe Kapitel \ref{sec:appSichtAnzeige}).

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.9\textwidth]{./img/App_Klassendiagramm_View}
    \caption{Klassendiagramm Komponente \enquote{View}}
    \label{fig:appKlassendiagrammView}
	\subfigure{\includegraphics[width=0.45\textwidth]{./img/App_Klassendiagramm_DisplayFeature}}
	\label{fig:appKlassendiagrammDisplayFeature}
	\subfigure{\includegraphics[width=0.45\textwidth]{./img/App_Klassendiagramm_Dialog}}
    \label{fig:appKlassendiagrammDialog}
	\caption{Klassendiagramm Komponenten \enquote{DisplayFeature} \& \enquote{Dialog}}
	\label{fig:appKlassendiagrammDisplayFeatureDialog}
  \end{center}
\end{figure}

In Paket \enquote{DisplayFeature} (siehe Abbildung \ref{fig:appKlassendiagrammDisplayFeatureDialog})) sind Funktionen für die Anzeige von Elementen enthalten (Sie Kapitel \ref{sec:appAnzeigeelemente}). Darunter befindet sich das \enquote{ErrorPanel}, welches bei unerwarteten Fehlern, diesen am oberen Rand des Displays darstellt. 
\\
Um einen Verbindungsfehler, bzw. noch nicht verbundenen Zustand zum Dongle zu signalisieren, gibt es das \enquote{NoConnectionPanel}. Dieses stellt ein Overlay da, welches vor den anderen Anzeigeelementen erscheint.
\\
Für einen leichteren Einstieg in die App gibt es optional die Anzeigehilfe \enquote{SwipeHelp}, die signalisiert, dass durch das wischen nach Links und Rechts weitere Sichten zur Verfügung stehen. Diese blendet sich automatisch nach ein paar Sekunden nach App-Start aus und kann auch komplett über die Optionen deaktiviert werden.
\\
Die Klasse \enquote{ViewCircles} zeigt am unteren Ende des Displays die aktuell ausgewählte Sicht, durch ausgefüllte bzw. unausgefüllte Kreise, an.
\\
In der Komponente \enquote{Dialog} (siehe Abbildung \ref{fig:appKlassendiagrammDisplayFeatureDialog})) befindet sich die gleichnamige Klasse und deren Hilfsklasse. Sie ist für das darstellen von Dialogen mit beliebigen Inhalt zuständig. So können leicht einfache Ja-Nein-Bestätigungsdialog und aufwändige Dialoge, wie zum Beispiel das Suchen der Bluetooth Geräte im Umfeld (siehe Kapitel \ref{sec:appSichtKonfiguration}), implementiert werden.

\subsection{Buildsystem}

Als Buildsystem für die Smartphone-App wurde \enquote{gulp.js} gewählt. Gulp führt dabei ein definiertes Script (ähnlich des Build-Management-Tools make) aus. In diesem File werden sogenannte Tasks in JavaScript definiert. Diese Gulp-Tasks werden direkt über die IDE (z.B VS-Code) bzw. der Shell ausgeführt. Abbildung \ref{fig:appBuildsystemAktivitatsdiagramm}a zeigt das Vorgehen des definierten Gulp-Tasks (siehe Kapitel \ref{sec:appGrundgerust}). Zuerst werden Variablen generiert und Bilder von den Ressourcen in die Sass-Files eingebunden. Danach werden die Sass Dateien zu CSS Dateien und die TypeScript Dateien zu JavaScript kompiliert. Optional kann beim Release-Task eine Obfuskierung und Komprimierung des Codes durchgeführt werden.
\\
Zur leichteren Entwicklung ist ein Watch-Task implementiert worden (Sie Abbildung \ref{fig:appBuildsystemAktivitatsdiagramm}b). Dieser funktioniert wie ein \enquote{Watchdog} auf die einzelnen Dateien und triggert bei Modifikation, je nach Dateityp, das kompilieren der einzelnen Dateien bzw., falls benötigt, des ganzen Systems.

\begin{figure}[H]
  \begin{center}
	\subfigure[Task Debug]{\includegraphics[width=0.22\textwidth]{./img/App_Buildsystem_Aktivitatsdiagramm_Debug}}
    \label{fig:appBuildsystemAktivitatsdiagrammDebug}
	\subfigure[Task Watch]{\includegraphics[width=0.65\textwidth]{./img/App_Buildsystem_Aktivitatsdiagramm_Watch}}
	\label{fig:appBuildsystemAktivitatsdiagrammWatch}
	\caption{Aktivitätsdiagramm Buildsystem}
	\label{fig:appBuildsystemAktivitatsdiagramm}
  \end{center}
\end{figure}

\subsection{Testumgebung}

Da die App auf HTML basiert und Plattform unabhängig ist, gibt es durch mehrere Testumgebungen diverse Möglichkeiten zum testen. Für einfache Tests ohne viel Anforderungen (z.B. Oberflächen- / Responsive- / Designtest) kann die App einfach im Browser geöffnet werden. Falls Device spezifische Funktionen (z.B. GPS, Bluetooth) benötigt werden, kann die App als Windows Anwendung, in einen Android Emulator oder direkt auf einem Endgerät vollständig gedebuggt werden (siehe Kapitel \ref{sec:appTest}). 



\section{Dongle}
\begin{sidewaysfigure}
  \begin{center}
    \includegraphics[width=\textwidth,height=15cm,keepaspectratio]{./img/Dongle_Arch_final}
    \caption{Architektur der Dongle-Software}
    \label{fig:dongleArch}
  \end{center}
\end{sidewaysfigure}
Um die Fahrzeugdaten gemäß den beschriebenen Use-Cases erfassen zu können, wurden mehrere Freematics ONE beschafft. Dieser Dongle bietet im Gegensatz zu manch anderen Adaptern die Möglichkeit Daten auf eine SD-Karte zu schreiben, mit Bluetooth zu kommunizieren und auf möglichst einfache Weise die darauf befindliche Software zu verändern. Wie auf der Produkthomepage beschrieben, nutzt der Dongle als Haupt-Controller einen ATmega328p, wie er auch auf einem Arduino UNO verwendet wird. Bei der Architektur der Dongle-Software wird deshalb für den Programmablauf ein für Arduino-Projekte klassischer Aufbau mit einer \enquote{setup}- und einer \enquote{loop}-Funktion innerhalb einer main-Datei verwendet.
\paragraph{}
Um bei der Entwicklung der Software für den Dongle möglichst wenig Inhaltsüber-schneidungen der Teammitglieder zu erreichen und um die Verständlichkeit und Wartbarkeit des Codes zu verbessern wurde entschieden die Schichtenarchitektur wie in Bild \ref{fig:dongleArch} umzusetzen.
Hierbei wird für die meisten Funktionsmerkmale mindestens eine Klasse auf der Intermediate-Layer sowie der Driver-Layer implementiert. Dies hat zur Folge, dass bei einer Funktionsänderung wie beispielsweise der Verwendung eines anderen GPS-Empfängers nur die entsprechende Treiber-Klasse geändert werden muss. Die Hauptklasse mit der eigentlichen Programmlogik bleibt dabei unangetastet.\\
Die im Bild \ref{fig:dongleArch} mit \enquote{(Fm)} ergänzten Klassen werden aus den Bibliotheken des Herstellers übernommen.
\subsection{GPS-Empfänger}
Da ein zentrales Ziel der Applikation die Anfertigung eines Fahrtenbuches mit Streckenaufzeichnung ist, muss auch die Position des Fahrzeuges möglichst genau bestimmt werden. Der in diesem Projekt verwendete Freematics ONE bietet hier die Möglichkeit, einen externen GPS-Empfänger über eine \ac{UART}-Schnittstelle anzubinden.
\paragraph{}
Um die Anschaffungskosten zu reduzieren, wurde zunächst untersucht, ob neben dem von Freematics verkauften GPS-Empfänger auch andere GPS-Receiver-Chips mit dem OBD-Dongle kompatibel sind.
Ein Problem bei dieser Untersuchung ist die Architektur des Freematics ONE, da die Kommunikation mit dem GPS-Empfänger nicht auf dem ATmega328p Haupt-Controller sondern auf einem STM32 Coprozessor ausgeführt wird. Leider ist der Code auf dem Coprozessor nicht öffentlich einsehbar und auch nicht ohne großen Aufwand auslesbar.
Ein weiteres Problem bestand darin, dass auch ein Öffnen des Gehäuses des von Freematics selbst vertriebenen GPS-Empfängers nicht zur Identifikation des Chips beitragen konnte. Es wurde allerdings klar, dass dieser nicht der Angabe auf der Produkthomepage des Freematics ONE entsprach. Der Empfänger-Chip ist nur mit einem QR-Code versehen und eine Recherche zum Hersteller verwies nur auf den chinesischen Produzenten des ganzen Empfänger-Moduls.(www.szgrltd.com)
\paragraph{}
Daher wurde eine andere Vorgehensweise zur Untersuchung der Kommunikation angewandt. Dazu wurde, wie in Abbildung \ref{fig:gpsAnalyse} abgebildet, ein zusätzlicher Arduino UNO als Zwischenstation in die UART-Kommunikation zwischen Dongle und Empfänger eingefügt. Zwei durch Software simulierte, serielle Schnittstellen auf dem Arduino UNO werden nun genutzt, um die vom Dongle und vom GPS-Empfänger gesendeten Daten aufzufangen, auf der über USB angeschlossenen seriellen Konsole eines Rechners auszugeben und an den jeweils anderen Kommunikationspartner weiterzuleiten.
\begin{figure}
  \begin{center}
    \includegraphics[width=\textwidth]{./img/gpsVersuch}
    \caption{Versuchsaufbau zur Analyse der UART-Kommunikation zwischen Dongle und GPS-Empfänger}
    \label{fig:gpsAnalyse}
  \end{center}
\end{figure}
\paragraph{}
Nach Auswertung der Kommunikation, stand fest, dass der von Freematics gelieferte GPS-Empfänger kompatibel zu einem u-blox UBX-G7020 ist. Dieser versendet standardmäßig Nachrichten gemäß dem \ac{NMEA} Standard. Darüber hinaus wurde ersichtlich, dass der OBD-Dongle keine Nachrichten zum GPS-Chip sendet.
\paragraph{}
Da nun allerdings der konkrete Empfänger feststand, konnte dazu die entsprechende Protocol Specification heruntergeladen und mit weiteren GPS-Empfängern verglichen werden.
Letztendlich wurde ein Pixhawk GPS Empfänger für einen Modellbau-Quadrokopter auf Basis eines u-blox Neo6M mit zusätzlichem Magnetfeld-Sensor ausgewählt. Dieser Mikrochip verfügt zwar nicht über die exakt gleiche Protocol Specification, die ab Werk konfigurierte Kommunikation jedoch ist nahezu identisch und kompatibel mit der des von Freematics gelieferten Produktes.
\paragraph{}
Um den neuen Empfänger am Dongle zu betreiben, wurde an dessen Signal-Eingängen ein 2x2-Molex Stecker passend angelötet. Die I2C-Pins des Magnetfeld-Sensors wurden dabei nicht belegt.
\paragraph{}
Ein erster Test mit der von Freematics bereitgestellten Software zeigte die grundsätzliche Funktion des neuen GPS-Moduls. Allerdings ist die Genauigkeit des Pixhawk-Empfängers etwas schlechter als die des UBX-G7020.

	\subsection{ \ac{OBD}-Schnittstelle}
		Da der Dongle vorwiegend genutzt werden soll um die \ac{OBD}-Daten (kurz \acp{PID}) aufzuzeichnen besitzt der Freematics ONE eine hierfür passende Schnittstelle. Bei den \acp{PID}\cite{OBD-2.net2018} handelt es sich um Daten die von bestimmten Sensoren (z.B. Drehzahl, Geschwindigkeit, Öl-Temperatur, ...) im Auto zu Verfügung gestellt werden.
		\ \\
		Bei \ac{OBD} handelt es sich um ein Protokoll welches nach dem \enquote{challenge-response}-Prinzip funktioniert. Dabei werden vom Client (Dongle) Anfragen an den Server (\ac{OBD}-Steuergerät im Auto) gesendet. Dieses antwortet anschließend mit den Werten des entsprechenden Sensors.
		\ \\
		Da es vom vorliegenden Auto abhängig ist, welche Steuergeräte verbaut sind und somit auch was für \acp{PID} unterstützt werden, ist es nicht bei jedem Auto möglich die selben Daten auszulesen.
		\ \\
		Da weiterhin der Platz auf dem Freematics ONE (sowohl RAM als auch Flash) sehr begrenzt ist, wurde von vorne herein entschieden, nur bestimmte \acp{PID} zu verwenden. Insgesamt wurden xy viele \acp{PID} ausgewählt. Um sowohl die \ac{OBD}-Schnittstelle als auch den Prozessor im Freeatics ONE unter wenig Last auszusetzen, dabei allerdings möglichst viel Nutzen aus den gewonnen Informationen ziehen zu können, wurden die \acp{PID} in unterschiedliche Gruppen eingeteilt. 
		\ \\
		Eine Gruppe entspricht somit einem Zusammenschluss aus \acp{PID} welche alle in einem gleichen Zeitintervall abgerufen werden. Es wurde sich für folgende Gruppen entschieden (Tabelle \ref{KategorieTable}):
		
		\begin{center}
			\begin{tabular}{|c|c|}
				\hline 
				Kategorie & Intervall \\ 
				\hline 
				A & 500ms \\ 
				\hline 
				B & 1,5s \\ 
				\hline 
				C & 15s \\ 
				\hline 
				D & 5min \\ 
				\hline 
				E & neue Route \\ 
				\hline 
				F & neues Auto \\ 
				\hline 
			\end{tabular} 
			\label{KategorieTable}		
		\end{center}

		
		Der Tabelle \ref{KategorieTable} kann zum einen entnommen werden, welche \acp{PID} ausgewählt wurden und in welcher Kategorie sie zugeordnet wurde.
		
		\begin{center}
			\begin{tabular}{|c|c|c|}
				\hline 
				Name & Wert & Kategorie \\ 
				\hline 
				Engine coolant temperature & 0x05 & C \\ 
				\hline 
				Engine RPM & 0x0C & A \\ 
				\hline 
				Vehicle speed & 0x0D & A \\ 
				\hline 
				Run time since engine start & 0x1F & C \\ 
				\hline 
				Distance traveled with malfunction indicator lamp & 0x21 & D \\ 
				\hline 
				Fuel tank level input & 0x2F & D \\ 
				\hline 
				Absolute barometric pressure & 0x33 & C \\ 
				\hline 
				Ambient ari temperature & 0x46 & C \\ 
				\hline 
				Fuel type & 0x51 & E \\ 
				\hline 
				Ethanol fuel \% & 0x52 & E \\ 
				\hline 
				Relative accelerator pedal position & 0x5A & A \\ 
				\hline 
				Engine oil temperature & 0x5C & C \\ 
				\hline 
				Engine fuel rate & 0x5E & A \\ 
				\hline 
				Driver's demand engine-percent torque & 0x61 & A \\ 
				\hline 
				Actual engine-percent torque & 0x62 & A \\ 
				\hline 
				Engine reference torque & 0x63 & A \\ 
				\hline 
				Engine run time & 0x7F & C \\ 
				\hline 
			\end{tabular} 
		\end{center}
		

\subsection{Zeit}
Wie bereits erwähnt, muss auch auf dem Dongle eine Repräsentation der genormten Zeit vorhanden sein. Zunächst soll jeder erfasste Datenwert mit einem Zeitstempel versehen werden um mit einer totalen Ordnung die Analyse dieser Werte erst zu ermöglichen. Zum anderen sollen die Datenwerte mit einem Intervall von 500 Millisekunden erfasst werden.
\paragraph{}
Die Anforderung nach einem genauen Zeitintervall von 500 Millisekunden zwischen dem Abrufen der OBD-Werte der Kategorie A kann durch den Einsatz eines Hardware-Timers und Interrupts gelöst werden.
Auf dem ATmega328p Hauptcontroller stehen dem Entwickler 3 Hardware-Timer zur Verfügung. Allerdings muss hierbei beachtet werden, dass die Arduino-Bibliothek den Timer 0 für die Funktionen delay() und millis() verwendet und dieser daher unangetastet bleiben sollte.\cite{arduinoTimer}
Da die Intervalle zum Abrufen der PID-Kategorien B, C und D ein Vielfaches der 500 Millisekunden der Kategorie A sind, müssen für diese keine weiteren Timer verwendet werden. Statt dessen kann ein einfacher Vergleich in Kombination mit dem Modulo-Operator genutzt werden (vgl. Abbildung \ref{fig:loop}).
\subsection{Beschleunigungssensor}
Zunächst wurde ermittelt, welcher Sensor im Dongle verbaut wurde. Anhand der Informationen auf der Produkthomepage sowie des Source-Codes des Treibers wurde ersichtlich, dass ein MPU-9250 \ac{MEMS}-Sensor mit jeweils 3 Achsen für Beschleunigungs-, Drehraten- und Magnetfeldmessung verbaut ist. Hierbei ist besonders, dass der Sensor für das Magnetfeld als I²C-Submodul am Sensor ausgeführt ist.
\subsection{Programmlogik}
\label{subsec:ProgLogik}
Die eigentliche Programmlogik kann wie bereits erwähnt in die Teile \enquote{Setup} und \enquote{Loop} getrennt werden.
\begin{figure}
  \begin{center}
    \includegraphics[width=\textwidth,height=10cm,keepaspectratio]{./img/Startup}
    \caption{Programmablauf der Initialisierung}
    \label{fig:setup}
  \end{center}
\end{figure}
\paragraph{}
Die Abbildung \ref{fig:setup} beschreibt den Ablauf des Programms beim Einstecken des Adapters in die Schnittstelle des Autos. Hervorzuheben ist, dass die Reihenfolge der Initialisierungen von großer Bedeutung ist. Näheres dazu wird im Kapitel \ref{subsec:intPl} erklärt.
\begin{figure}
  \begin{center}
    \includegraphics[width=\textwidth,height=20cm,keepaspectratio]{./img/ProgLoop}
    \caption{Programmablauf der Endlosschleife}
    \label{fig:loop}
  \end{center}
\end{figure}
In Abbildung \ref{fig:loop} ist der Ablauf des Programms ersichtlich, welches die eigentliche Funktionalität enthält. Dies wurde in drei Modi umgesetzt. Während des Logging-Modus werden die Fahrzeug-Daten gesammelt, auf eine SD-Karte geschrieben und per Bluetooth an ein Smartphone gesandt. Der Upload-Modus dient dazu, die gesammelten Daten auf der SD-Karte an die Smartphone-App weiterzugeben. Dies soll ein Entnehmen der Karte zum Auslesen der Daten optional machen. Der Schlafmodus dient letztendlich dazu, bei abgeschalteter Zündung das Bordnetz des Fahrzeugs möglichst wenig zu belasten.
