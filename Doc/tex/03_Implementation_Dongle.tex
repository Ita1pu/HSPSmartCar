\section{Dongle}

\subsection{GPS und Zeit} 
\label{ImplGpsUndZeit}
Um den GPS-Empfänger auch in der in diesem Projekt geschriebenen Dongle-Software zu nutzen, wurde zunächst der Code des von Freematics veröffentlichten Treibers für den Coprozessor übernommen, da dieser den Datenaustausch mit dem Empfänger regelt und die serielle Schnittstelle mit diesem verbunden ist. Um die Kommunikation von der eigentlichen Anwendungslogik abzutrennen, wurde eine weitere LocationTimeService-Klasse auf Ebene der Intermediate-Layer implementiert. Diese bietet nun vereinfachten Zugriff auf die gemessenen Werte des geografischen Längen- und Breitengrads, der Höhe über Normalnull und die Anzahl der verfügbaren Satteliten. Darüber hinaus stellt sie auch Funktionen zum erneuten Abrufen und Speichern der GPS-Daten und zur Initialisierung der Kommunikation mit dem GPS-Chip über UART zur Verfügung. Dabei ist zu beachten, dass die Anzahl der Satelliten für eine möglichst korrekte Positionsbestimmung zwischen 4 und 14 liegen muss \cite{gpsPrecision}.

Während der Initialisierung des LocationService, wird bis zu fünf mal versucht, über den Treiber des Coprozessors eine serielle Datenübertragung aufzubauen. Um die Genauigkeit vor allem des Pixhawk-Empfängers zu verbessern, wird während der Initialisierung der LocationService-Klasse der Intermediate Schicht der GPS-Chip für die Nutzung für \ac{SBAS} konfiguriert. Dazu wird die write-Methode des Treibers genutzt, mit dem ein Byte-Array 1:1 übertragen werden kann.
Gemäß der Protocol-Specification beider GPS-Module, kann SBAS mit folgendem Code konfiguriert werden:
\begin{lstlisting}
  uint8_t cmd[] = {0xB5, 0x62, 0x06, 0x16, 0x00, 0x08, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x51, 0x7F, 0xEE };
  uint8_t cmdLen = 15;
  [...]
  //send config command
  _coProc->setTarget(TARGET_GPS);
  _coProc->write(cmd, cmdLen);
\end{lstlisting}

Um die Kommunikation mit dem Coprozessor nicht unnötig zu belasten und die Verarbeitung der OBD-Daten auf diesem nicht zu kompromittieren, werden die Sensordaten nur nach Bedarf mit der Methode RenewGPSData in Member-Variablen der LocationTimeService-Klasse zwischengespeichert. Ein Aufruf der Getter-Methoden führt nur dazu, dass diese zwischengespeicherten Werte ausgegeben werden.
\paragraph{}
Da mit dem GPS auch Zeitinformationen übertragen werden, werden diese genutzt, um die aktuelle Zeit auf dem System verfügbar zu machen. Dazu erhält die LocationTimeService-Klasse zusätzliche Methoden um die Hardware-Timer 1 und 2 zu konfigurieren und um die Millisekunden seit dem 1.1.1970 abzurufen. Diese Zeit wird in der LocationTimeService-Klasse als Membervariable zwischengespeichert.
\paragraph{}
Um die GPS-Information zur \enquote{Unix-Epoch} umzuwandeln wird auf Funktionen der Header-Datei \enquote{time.h} zurückgegriffen, welche in der Arduino Header Sammlung enthalten ist. Allerdings muss während der Konversion der Wert 946684800 hinzuaddiert werden, da Arduino die Epoch seit dem 1.1.2000 rechnet und der genannte Wert den Sekunden zwischen 1.1.1970 und 1.1.2000 entspricht. Bei der Rückgabe der Millisekunden muss darauf geachtet werden, dass ein Datentyp mit 64 Bit verwendet wird und auch keine impliziten Umwandlungen bei der Berechnung auftreten.
\paragraph{}
In diesem Zuge wird Timer 1 mit global sichtbaren Funktionen und einem Interrupt so konfiguriert, um das Logging-Intervall von 500 ms einzuhalten. Timer 2 wird ähnlich konfiguriert, sorgt aber dafür, dass der zwischengespeicherte Epoch-Wert alle 8 Millisekunden um diesen Wert erhöht wird. Dadurch muss nicht jedes mal die GPS-Zeit abgerufen werden, wenn der Zeitstempel benötigt wird.

\subsection{ \ac{OBD}-Schnittstelle}
	Da die Kommunikation mit der \ac{OBD}-Schnittstelle ebenfalls über den Coprozessor abgewickelt wird, von welchem die Software nicht bekannt ist, wurde hier die von Freematics bereitgestellte Klasse \enquote{COBDSPI} verwendet. Diese stellt gewisse Funktionen wie z.B. Auslesen einer \ac{PID} oder der \ac{VIN}. Da diese Funktionen allerdings komplizierter zu verwenden sind, wurde auch hierfür auf der Ebene der Intermediate-Layer eine neue Klasse erzeugt mit der es einfacher ist die \ac{PID}-Kategorien auszulesen und für die weitere Verarbeitung zu verpacken.
	\\
	Da bei \ac{OBD} zwar der Stecker spezifiziert ist, es allerdings trotzdem unterschiedliche Protokolle gibt welche sich durch die Belegung der Pins unterscheiden, sorgt die Implementierung außerdem dafür, dass das passende Protokoll gefunden und für spätere Neuverbindungen gespeichert wird.
	\\
	Die neue Klasse stellt weiterhin eine Methode zu Verfügung mit der es möglich ist zu erkennen, ob beim Auto die Zündung getätigt wurde. Dies ist wichtig, da die \ac{OBD}-Schnittstelle (bei den meisten Autos) dauerhaft mit Strom versorgt ist. Aus diesem Grund kann nicht auf einen Neustart des Fahrzeugs gewartet werden um zu entscheiden ob es sich um eine neue Strecke handelt.
	\\
	Die Funktion überprüft wie viele Timeouts beim Versuch \acp{PID} auszulesen auftreten. Sobald diese Anzahl einen Grenzwert überschreitet, wird davon Ausgegangen, dass die Zündung nicht mehr aktiviert ist. Anschließend kann in Regelmäßigen Abständen geprüft werden ob inzwischen wieder Kommunikation mit dem \ac{OBD}-Steuergerät möglich ist. 
	


\subsection{Beschleunigungssensor}
Der Treiber für den im Dongle verbauten Beschleunigungs-Sensor wurde nicht von Freematics übernommen sondern in Anlehnung an diesen neu Implementiert. Dies geschah vor allem um die Einheit der aufgezeichneten Sensorwerte selbst zu definieren und verständlicher darzustellen, sowie um Platz auf dem Flash-Speicher zu sparen.
\paragraph{}
Die AccReader-Klasse stellt nun Methoden zur Verfügung, welche für eine anzugebende Achse die Beschleunigung in g, die Rotation in Grad pro Sekunde und das Magnetische Feld in $\mu$-Tesla zurückgeben. Darüber hinaus kann auch die Absolut-Beschleunigung zurückgegeben werden und die aktuellen Beschleunigungs- und Gyroskopwerte als \enquote{0} kalibriert werden. Dabei ist zu bemerken, dass für das Gyroskop Biaswerte direkt in Register auf dem Sensor geschrieben werden können, wohingegen diese Biaswerte für den Beschleunigungssensor im RAM des Haupt-Controllers vorgehalten werden müssen.
\subsection{Programmlogik}
\label{subsec:intPl}
Die Implementierung der Programmlogik erfolgte weitestgehend nach dem in Kapitel \ref{subsec:ProgLogik} vorgestellten Abläufen. Um den Zustand des Programms während der Endlosschleife zu erfassen, wurde eine Datenstruktur definiert, welche den Modus sowie den Schleifenzähler umfasst. Somit kann das Programmverhalten durch die Veränderung einer lokal sichtbaren Datenstruktur beeinflusst werden.
\paragraph{}
Um die erfassten Beschleunigungs- und GPS-Daten genau so wie die OBD-Werte loggen zu können, mussten für diese noch eigene IDs vergeben werden. Dazu wurde der Bereich 0xF0 bis 0xFF gewählt, da diese im OBD-Protokoll nicht zur Erfassung von Fahrzeugdaten verwendet werden \cite{ISOobd}.
\paragraph{}
Während der Integration aller Klassen trat jedoch ein schwerwiegendes Problem auf. Wie bereits in Kapitel \ref{subsec:ProgLogik} erwähnt, traten massive Speicherprobleme auf. Zu diesem Zeitpunkt wurden alle funktionalen Klassen erst vor ihrer Initialisierung instantiiert und die Persistenzklasse war dabei als Letztes vorgesehen. Allerdings zeigte der Dongle bei der Initialisierung der Persistenz-Klasse ein undefinierbares Verhalten mit sporadischen Software-Abstürzen. Dies legte eine Knappheit von RAM nahe. Mit der von Bill Earl vorgestellten Funktion \enquote{freeMemory()} \cite{ardRAMcons} konnte nachgewiesen werden, dass zum Öffnen bzw. Erstellen einer Datei auf der SD-Karte mindestens 384 Byte im RAM verfügbar sein müssen. Allerdings wurde bei der Analyse des Speicherbedarfes auch ersichtlich, dass zum Schreiben in die bereits geöffnete Datei weniger Platz auf dem Heap benötigt wird.
\paragraph{}
Um diesem Problem entgegenzuwirken wurden mehrere Maßnahmen getroffen. Zunächst wurden alle Strings, sofern diese auch wirklich benötigt werden, mithilfe des Makros \enquote{F()} auf den Programmspeicher im Flash des $\mu$-Controllers ausgelagert und mehrere Funktionen als inline-Funktionen deklariert \cite{ardRAMopt}. Damit soll der Stack und damit der gesamte RAM-Verbrauch optimiert werden. Darüber hinaus wurden die meisten funktionalen Klassen nun nicht mehr mit dem new-Operator instantiiert, sondern als global verfügbare Objekte geführt. Dies stellt einen Versuch dar, der Speicherfragmentierung bei der dynamischen Instantiierung entgegenzuwirken. Auch wird nun die Initialisierung der Persistenzklasse sofort nach der Initialisierung der LocationTimeService-Klasse durchgeführt, da zu diesem Zeitpunkt einige der verbliebenen, dynamisch allokierten Klassen noch nicht instantiiert sind und somit mehr RAM zur Verfügung steht.
Ebenfalls erfolgt die Speicherung der abgefragten OBD-Werte nicht mehr in einem Array, welches groß genug ist für alle Werte. Dieses Array wurde nun so verkleinert, dass es nur noch für alle PIDs der umfangreichsten Logging-Kategorie (je nach Fahrzeug entweder Kategorie A oder Kategorie B) ausreicht. Dabei müssen allerdings die alten PID-Werte bei jedem Wechsel der Logging-Kategorie gelöscht werden.
